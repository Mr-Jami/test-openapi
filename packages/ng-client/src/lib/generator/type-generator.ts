import { Project, SourceFile, InterfaceDeclaration, TypeAliasDeclaration } from 'ts-morph';
import { SwaggerParser, SwaggerDefinition, SwaggerProperty } from './swagger-parser';

export class TypeGenerator {
    private project: Project;
    private parser: SwaggerParser;
    private sourceFile: SourceFile;

    constructor(swaggerPath: string, outputPath: string) {
        this.project = new Project({
            compilerOptions: {
                declaration: true,
                target: 2, // ES2015
                module: 1, // CommonJS
                strict: true,
            },
        });

        this.parser = new SwaggerParser(swaggerPath);
        this.sourceFile = this.project.createSourceFile(outputPath, '', { overwrite: true });
    }

    generate(): void {
        const definitions = this.parser.getDefinitions();

        // Add file header comment
        this.sourceFile.insertText(0, `/**
 * Generated TypeScript interfaces from Swagger specification
 * Do not edit this file manually
 */

`);

        // Generate interfaces for each definition
        Object.entries(definitions).forEach(([name, definition]) => {
            this.generateInterface(name, definition);
        });

        // Save the file
        this.sourceFile.saveSync();
    }

    private generateInterface(name: string, definition: SwaggerDefinition): void {
        const interfaceName = this.pascalCase(name);

        if (definition.enum) {
            this.generateEnum(interfaceName, definition);
            return;
        }

        if (definition.allOf || definition.oneOf || definition.anyOf) {
            this.generateCompositeType(interfaceName, definition);
            return;
        }

        const interfaceDeclaration = this.sourceFile.addInterface({
            name: interfaceName,
            isExported: true,
        });

        this.addInterfaceProperties(interfaceDeclaration, definition);
    }

    private generateEnum(name: string, definition: SwaggerDefinition): void {
        if (!definition.enum) return;

        const enumDeclaration = this.sourceFile.addEnum({
            name,
            isExported: true,
        });

        definition.enum.forEach((value) => {
            const enumKey = this.toEnumKey(value);
            enumDeclaration.addMember({
                name: enumKey,
                value: value,
            });
        });
    }

    private generateCompositeType(name: string, definition: SwaggerDefinition): void {
        let typeExpression = '';

        if (definition.allOf) {
            const types = definition.allOf.map(def => this.getTypeFromDefinition(def));
            typeExpression = types.join(' & ');
        } else if (definition.oneOf) {
            const types = definition.oneOf.map(def => this.getTypeFromDefinition(def));
            typeExpression = types.join(' | ');
        } else if (definition.anyOf) {
            const types = definition.anyOf.map(def => this.getTypeFromDefinition(def));
            typeExpression = types.join(' | ');
        }

        this.sourceFile.addTypeAlias({
            name,
            type: typeExpression,
            isExported: true,
        });
    }

    private addInterfaceProperties(interfaceDeclaration: InterfaceDeclaration, definition: SwaggerDefinition): void {
        if (!definition.properties) return;

        Object.entries(definition.properties).forEach(([propertyName, property]) => {
            const isRequired = definition.required?.includes(propertyName) || false;
            const propertyType = this.getTypeFromProperty(property);

            interfaceDeclaration.addProperty({
                name: propertyName,
                type: propertyType,
                hasQuestionToken: !isRequired,
                docs: property.description ? [property.description] : undefined,
            });
        });
    }

    private getTypeFromProperty(property: SwaggerProperty): string {
        if (property.$ref) {
            const refDefinition = this.parser.resolveReference(property.$ref);
            const refName = property.$ref.split('/').pop();
            return refName ? this.pascalCase(refName) : 'any';
        }

        if (property.allOf) {
            const types = property.allOf.map(def => this.getTypeFromDefinition(def));
            return types.join(' & ');
        }

        if (property.oneOf) {
            const types = property.oneOf.map(def => this.getTypeFromDefinition(def));
            return types.join(' | ');
        }

        if (property.anyOf) {
            const types = property.anyOf.map(def => this.getTypeFromDefinition(def));
            return types.join(' | ');
        }

        if (property.enum) {
            return property.enum.map(value =>
                this.toEnumKey(value)
            ).join(' | ');
        }

        if (property.type === 'array') {
            const itemType = property.items ? this.getTypeFromProperty(property.items) : 'any';
            return `${itemType}[]`;
        }

        if (property.type === 'object') {
            if (property.properties) {
                const properties = Object.entries(property.properties)
                    .map(([key, prop]) => {
                        const isRequired = property.required?.includes(key) || false;
                        const questionMark = isRequired ? '' : '?';
                        return `${key}${questionMark}: ${this.getTypeFromProperty(prop)}`;
                    })
                    .join('; ');
                return `{ ${properties} }`;
            }
            return 'Record<string, any>';
        }

        return this.mapSwaggerTypeToTypeScript(property.type, property.format);
    }

    private getTypeFromDefinition(definition: SwaggerDefinition): string {
        if (definition.$ref) {
            const refName = definition.$ref.split('/').pop();
            return refName ? this.pascalCase(refName) : 'any';
        }

        if (definition.type === 'object' && definition.properties) {
            const properties = Object.entries(definition.properties)
                .map(([key, prop]) => {
                    const isRequired = definition.required?.includes(key) || false;
                    const questionMark = isRequired ? '' : '?';
                    return `${key}${questionMark}: ${this.getTypeFromProperty(prop)}`;
                })
                .join('; ');
            return `{ ${properties} }`;
        }

        return this.mapSwaggerTypeToTypeScript(definition.type, undefined);
    }

    private mapSwaggerTypeToTypeScript(type?: string, format?: string): string {
        if (!type) return 'any';

        switch (type) {
            case 'string':
                if (format === 'date' || format === 'date-time') return 'string'; // or Date if you prefer
                return 'string';
            case 'number':
            case 'integer':
                return 'number';
            case 'boolean':
                return 'boolean';
            case 'array':
                return 'any[]';
            case 'object':
                return 'Record<string, any>';
            default:
                return 'any';
        }
    }

    private pascalCase(str: string): string {
        return str.replace(/(?:^|[-_])([a-z])/g, (_, char) => char.toUpperCase());
    }

    private toEnumKey(value: string | number): string {
        return value.toString()
            .replace(/[^a-zA-Z0-9]/g, '_')
            .replace(/^([0-9])/, '_$1')
            .toUpperCase();
    }

    getProject(): Project {
        return this.project;
    }
}